					КАК ЮЗАТЬ СЕТЬ
		
header: 	NetLib.h; (+ добавить в проект Net.h)
library: 	NetLib.lib;
	
Функции класса Net возвращающие bool, возвращают true в случае успеха и false в случае облома.
Если произошел облом, то код ошибки можно получить с помощью:

	HRESULT Net::GetDPError();

а описание ошибки можно получить так:

	std::string GetDPErrorDescription(const HRESULT h);
	
	
				ПОРЯДОК ПОЛЬЗОВАНИЯ КЛАССОМ СЕТКИ

	1. Создать объект класса Net.
	
	2. Используя функции:
	
		bool Net::IsTCPConnectionAvailable();
		bool Net::IsIPXConnectionAvailable();
		
	   определить доступные коннекты (для доступных функция возвращает true).
	
	3. Приконнектиться, используя следующие функции:
	
		bool Net::ConnectByIPX();
		bool Net::ConnectByTCP(const char * strIPAddr, const WORD wPort = 0);
		
	   где strIPAddr - IP адрес сервера, по которому потом придется искать сессии.
	   Для локальной сети стока может быть пустой ( "", а не NULL), тогда будет поиск
	   по всей локалке.
	   wPort - адрес порта (может отсутствовать)
	   
	4. Осуществить поиск сессий, используя две функции и вектор найденных сессий
	   (если хочется создать свою сессию, то этот шаг можно пропустить)
	
	   Вектор найденных сессий содержит следующие структуры:
	   	
	   	// описание сессии
	   	typedef struct {
	   		// имя сессии (может содержать дополнительную информацию)
	   		char * pName;
			// короткое и длинное имя игрока
			char * pShortPlayerName;
			char * pLongPlayerName;
	   		// максимальное количество игроков
	   		DWORD dwMaxPlayers;
	   		// текущее количество игроков
	   		DWORD dwCurrentPlayers;
	   		// поле определяется пользователем
	   		DWORD dwUser1;
	   		// поле определяется пользователем
	   		DWORD dwUser2;
	   		// поле определяется пользователем
	   		DWORD dwUser3;
	   		// поле определяется пользователем
	   		DWORD dwUser4;
	   	} ST_SESSION;
	   	// вектор сессий
	   	typedef std::vector<ST_SESSION> SESSION_VECTOR;
	   	// итератор вектора сессий
	   	typedef SESSION_VECTOR::iterator SESSION_VECTOR_ITERATOR;
	   	
	   Начать поиск сессий следует функцией:
	   
	   	bool Net::UpdateEnumSessions(const DWORD dwPeriod = 0, const bool bAll = false);
	   	
	   Затем периодически вызывать эту же функцию, тем самым обновляя текущий вектор сессий.
	   Получить текущий вектор сессий:
	   	
	   	const SESSION_VECTOR& GetSessionVector();
	   	
	   Остановить поиск и, одновременно, обновить текущий список нужно функцией
	   
	   	bool StopEnumSessions(const bool bAll = false);
	   	
	5. Заджойниться и создать игрока (если создаем свою сессию - пункт 6):
	
		bool JoinSession(const int Index, char * ShortPlayerName, char * LongPlayerName);
	   
	   где Index - номер сессии в векторе найденных сессий, ShortPlayerName и LongPlayerName
	   это короткое и длинное имя игрока.

	6. Создать сессию и игрока:
	
		bool CreateSession(char * SessionName, char * ShortPlayerName,
				   char * LongPlayerName, DWORD u1 = 0, DWORD u2 = 0,
				   DWORD u3 = 0, DWORD u4 = 0);
	   
	   где SessionName - имя сессии, ShortPlayerName и LongPlayerName - короткое и длинное
	   имя игрока, u1 - u4 - поля определяемые пользователем.
	   
	5&6. Закрыть сессию можно функцией 
		
		bool CloseSession();
	   
	7. Если все предыдущие шаги выполнились удачно, то можно отсылать и принимать сообщения.
	   
		типы сообщений
			enum MES_TYPE {
			MT_NOMESSAGE,         // в очереди нет сообщений
			MT_GENERIC,           // обычное сообщение
			MT_CREATEPLAYER,      // системное сообщение - создан игрок
			MT_DESTROYPLAYER,     // системное сообщение - уничтожен игрок
			MT_SESSIONLOST,       // системное сообщение - потеряно соединение с сессией
			MT_CHANGEDPLAYERDATA, // системное сообщение - изменились данные игрока
			MT_SETPLAYERNAME,     // системное сообщение - изменилось имя игрока
			MT_SETSESSIONDDECS,   // системное сообщение - изменились данные сессии
			MT_UNKNOWN            // неизвестное сообщение
		};
		
	   Функция отправки сообщения
	   
	   	bool SendMessage(void* pBuffer, DWORD dwSize);

			pBuffer - указатель на буфер с сообщением, dwSize - размер сообщения
	
           Функция получения размера сообщения

		bool ReceiveMessage(DWORD* pdw);
			
			если вернула false - произошла ошибка, иначе - в (*pdw) лежит размер
			полученного сообщения. Если размер нулевой, то сообщений нет
	   	
	   Функция получения сообщения
	   
	   	Net::MES_TYPE ReceiveMessage(void* pBuffer, DWORD dwSize);

		копирует сообщение в предоставленный буфер (pBuffer) размера dwSize, и возвращает
		тип сообщения
	   	   	